#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el

* Emacs Configuration

** Lexical

#+NAME: lexical-binding
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

** Early Init
*** lexical binding
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el :noweb yes
<<lexical-binding>>
#+end_src

*** Managing Garbage Collection

Increase gc threshold to 100MB to increase the startup time temporarily
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (setq gc-cons-threshold (* 100 1000 1000))
#+end_src

*** Noise reduction
By setting byte-compile-warnings in this way,
I am telling Emacs not to produce warnings related to obsolete functions and variables during the byte-compilation process.
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (setq byte-compile-warnings '(not obsolete))
#+end_src

Supress noise logs related to compilation (=comp=) and byte-compilation (=bytecomp=).
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (setq warning-suppress-log-types '((comp) (bytecomp)))
  (setq native-comp-async-report-warnings-errors 'silent)
#+end_src
*** Startup Message
Simple hook which informs me how long it took and with how many garbage collections it did, to Emacs.
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (add-hook
   'emacs-startup-hook
   (lambda ()
     (message
      "*** Emacs loaded in %s with %d garbage collections."
      (format "%.2f seconds"
              (float-time
               (time-subtract after-init-time before-init-time)))
      gcs-done)))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")
  (setq inhibit-startup-echo-area-message (user-login-name))
#+end_src
*** Prefer newer
This means that it will prefer the newer version of a library if multiple versions are available.
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src
*** Maximum Read process output
This was suggested by lsp-mode for performance.
#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (setq read-process-output-max (* 1024 1024))
#+end_src

*** Default Frame Settings

#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t)
#+end_src

Default mode for the *scratch* buffer
#+NAME:initial-mode
#+begin_src emacs-lisp :tangle no
  '(initial-major-mode . fundamental-mode)
#+end_src

#+NAME: maximized
#+begin_src emacs-lisp :tangle no
  '(fullscreen . maximized)
#+end_src

#+NAME: no-vertical-sb
#+begin_src emacs-lisp :tangle no
  '(vertical-scroll-bars . nil)
#+end_src

#+NAME: no-horizontal-sb
#+begin_src emacs-lisp :tangle no
  '(horizontal-scroll-bars . nil)
#+end_src

#+NAME: default-background
#+begin_src emacs-lisp :tangle no
  '(background-color . "#24273a")
#+end_src

#+NAME: ns-dark
#+begin_src emacs-lisp :tangle no
  '(ns-appearance . dark)
#+end_src

#+NAME: ns-titlebar-transparent
#+begin_src emacs-lisp :tangle no
  '(ns-transparent-titlebar . t)
#+end_src

#+NAME: no-decorations
#+begin_src emacs-lisp :tangle no
  '(undecorated . t)
#+end_src

#+NAME: hide-scrollbar
#+begin_src emacs-lisp :tangle no
  '(scroll-bar-mode . nil)
#+end_src

#+NAME: hide-tooltip
#+begin_src emacs-lisp :tangle no
  '(tooltip-mode . -1)
#+end_src

#+NAME: hide-toolbar
#+begin_src emacs-lisp :tangle no
  '(tool-bar-mode . -1)
#+end_src

#+NAME: hide-menubar
#+begin_src emacs-lisp :tangle no
  '(menu-bar-mode . -1)
#+end_src

#+NAME: fring-10
#+begin_src emacs-lisp :tangle no
  '(set-fringe-mode . 10)
#+end_src

#+NAME: set-default-font
#+begin_src emacs-lisp :tangle no
;;    (face . ((default :font "Maple Mono" :height 180)))
;; (set-face-attribute `default nil :font "Maple Mono" :height 180)
#+end_src

#+NAME: escape-quit
#+begin_src emacs-lisp :tangle no
  ;;(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

#+NAME: no-default-load-avarage
#+begin_src emacs-lisp :tangle no
  '(display-time-default-load-average . nil)
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el :noweb yes
  (add-to-list 'default-frame-alist '(font . "Maple Mono-15"))
  (add-to-list 'default-frame-alist <<maximized>>)
  (add-to-list 'default-frame-alist <<no-vertical-sb>>)
  (add-to-list 'default-frame-alist <<no-horizontal-sb>>)
  (add-to-list 'default-frame-alist <<default-background>>)
  (add-to-list 'default-frame-alist <<ns-dark>>)
  (add-to-list 'default-frame-alist <<ns-titlebar-transparent>>)
  (add-to-list 'default-frame-alist <<no-decorations>>)
  (add-to-list 'default-frame-alist <<hide-scrollbar>>)
  (add-to-list 'default-frame-alist <<hide-menubar>>)
  (add-to-list 'default-frame-alist <<hide-toolbar>>)
  (add-to-list 'default-frame-alist <<hide-tooltip>>)
  (add-to-list 'default-frame-alist <<fring-10>>)
  ;;(add-to-list 'default-frame-alist <<set-default-font>>)
  ;;(add-to-list 'default-frame-alist <<escape-quit>>)
  (add-to-list 'default-frame-alist <<no-default-load-avarage>>)
  (add-to-list 'default-frame-alist <<initial-mode>>)
  (setq initial-frame-alist default-frame-alist)
  (setq-default truncate-lines t)
#+end_src

** Init
*** Lexical Binding
#+begin_src emacs-lisp :noweb yes
    <<lexical-binding>>
#+end_src

*** more frame tweaks
#+NAME: frame-settings
#+begin_src emacs-lisp :tangle no
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (set-fringe-mode 10)
  (visual-line-mode -1)
  (setq truncate-lines t)
  (setq-default truncate-lines t)
  (set-face-attribute `default nil :font "Maple Mono" :height 180)
#+end_src

#+RESULTS: frame-settings

#+begin_src emacs-lisp :noweb yes
(defun my-frame-tweaks (&optional frame)
  "My personal frame tweaks."
  (unless frame
    (setq frame (selected-frame)))
  (when frame
    (with-selected-frame frame
      (when (display-graphic-p)
    <<frame-settings>>))))

;; For the case that the init file runs after the frame has been created.
;; Call of emacs without --daemon option.
(my-frame-tweaks)
;; For the case that the init file runs before the frame is created.
;; Call of emacs with --daemon option.
(add-hook 'after-make-frame-functions #'my-frame-tweaks t)
#+end_src
*** Manage backup files
#+begin_src emacs-lisp
(setq backup-directory-alist
      `(("." . "~/.cache/emacs_backups/")))
(setq backup-by-copying t)
(setq
 delete-old-versions t
 kept-new-versions 6
 kept-old-versions 2
 version-control t)

#+end_src
*** Use-package
#+begin_src emacs-lisp
  (setq-default
   ;;use-package-always-defer t
   use-package-always-ensure t)

  (eval-when-compile
    (require 'use-package))
#+end_src
*** Personal Info
#+begin_src emacs-lisp
  (setq
   user-full-name "Perma"
   user-mail-address "prma.dev@protonmail.com")
#+end_src
*** gcmh
#+begin_src emacs-lisp
  (use-package gcmh
    :ensure t
    :demand t
    :config
    (gcmh-mode 1)
    )

#+end_src
*** Keybindings
**** which-key
#+begin_src emacs-lisp
  (use-package which-key
   :ensure t
   :init (which-key-mode)
   ;;:delight which-key-mode
   :custom (which-key-idle-delay 0.3))
#+end_src
**** Evil
***** Evil Bindings
#+begin_src emacs-lisp
  (use-package evil
   :delight evil-mode
   :init
   (setq evil-want-integration t)
   (setq evil-want-keybinding nil)
   (setq evil-want-C-u-scroll t)
   (setq evil-want-C-i-jump nil)
   :config
   (evil-mode 1)
   (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
   (evil-global-set-key 'motion "j" 'evil-next-visual-line)
   (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
   (evil-set-initial-state 'messages-buffer-mode 'normal)
   (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src
Evil mode for others
#+begin_src emacs-lisp
(use-package evil-collection
 :after evil
 :custom (Evil-collection-minibuffer-setup t)
 :config (evil-collection-init))
#+end_src

#+begin_src emacs-lisp
    (use-package
    evil-org
    :ensure t
    :after org
    :hook (org-mode . evil-org-mode)
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src
**** General
#+begin_src emacs-lisp
  (use-package general
    :config (general-evil-setup t)
    (general-create-definer
     rune/leader-keys
     :keymaps '(normal insert visual emacs)
     :prefix "SPC"
     :global-prefix "C-SPC"))
#+end_src
**** Window Moving
#+begin_src emacs-lisp
  (windmove-default-keybindings 'control)
#+end_src
**** Minibuffer
For help, see: https://www.masteringemacs.org/article/understanding-minibuffer-completion

Use the minibuffer whilst in the minibuffer
#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

completion-cycle-threshold
#+BEGIN_SRC emacs-lisp
  (setq completion-cycle-threshold 1)
#+END_SRC

Show annotations
#+BEGIN_SRC emacs-lisp
  (setq completions-detailed t)
#+END_SRC

When I hit TAB, try to complete, otherwise, indent
#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

Different styles to match input to candidates
#+BEGIN_SRC emacs-lisp
  (setq completion-styles
        '(basic initials substring))
#+END_SRC

Open completion always
#+BEGIN_SRC emacs-lisp
  (setq completion-auto-help 'always)
#+END_SRC

This is arbitrary
#+BEGIN_SRC emacs-lisp
  (setq completions-max-height 20)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq completions-detailed t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq completions-format 'one-column)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq completions-group t)
#+END_SRC

Much more eager
#+BEGIN_SRC emacs-lisp
  (setq completion-auto-select 'second-tab)
#+END_SRC

See `C-h v completion-auto-select' for more possible values
#+BEGIN_SRC emacs-lisp
;;(setq completion-auto-select t)
#+END_SRC

TAB acts more like how it does in the shell
#+BEGIN_SRC emacs-lisp
(keymap-set minibuffer-mode-map "TAB" 'minibuffer-complete)
#+END_SRC
**** Smooth scrolling
#+begin_src emacs-lisp

  (pixel-scroll-precision-mode 1)
  (defvar +scroll-delta 180)

  (defun +scroll-up-some ()
    (interactive)
    (pixel-scroll-precision-scroll-up +scroll-delta))

  (defun +scroll-down-some ()
    (interactive)
    (pixel-scroll-precision-scroll-down +scroll-delta))

  (defun +bind-scroll-keys (mode-map)
    (evil-define-key
     '(motion normal) mode-map (kbd "K") '+scroll-up-some)
    (evil-define-key
     '(motion normal) mode-map (kbd "J") '+scroll-down-some))

#+end_src
**** escape
#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

**** buffer
#+begin_src emacs-lisp
  (rune/leader-keys "c"
    '(message-kill-buffer :which-key "kill buffer"))
#+end_src
*** Garbage Collection
**** Collect Garbage When Losing Focus

#+begin_src emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+end_src
*** UI
**** SaveHist
Saves history of minibuffer
#+begin_src emacs-lisp
  (use-package savehist
    :init (savehist-mode 1))
#+end_src
**** Delight mode
Manipulates the showing of minor modes.
#+begin_src emacs-lisp
  (use-package delight)
#+end_src
**** UTF8
#+begin_src emacs-lisp
  (set-default-coding-systems 'utf-8)
  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
#+end_src
**** Themes
***** Doom Themes
Although I'm not using them, but it is fun to check them out and see what I'm missing.
#+begin_src emacs-lisp
  (use-package doom-themes
    :custom
   (doom-themes-enable-bold t)
   (doom-themes-enable-italic t))
#+end_src
***** Catppuccin Theme
my main theme
#+begin_src emacs-lisp
  (use-package catppuccin-theme
   :custom
   (catppuccin-flavor 'macchiato)
   (catppuccin-italic-comments t)
   :config (catppuccin-reload))
#+end_src
**** Modeline
***** Doom modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
   :delight
   :init (doom-modeline-mode 1)
   :custom
   (doom-modeline-height 20)
   (doom-modeline-icon (display-graphic-p))
   (doom-modeline-buffer-encoding nil))
#+end_src
**** Icons
#+begin_src emacs-lisp
  (use-package all-the-icons :if (display-graphic-p))
#+end_src

#+begin_src emacs-lisp
  (use-package  all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src
#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :ensure t
    :after all-the-icons
  )
#+end_src
**** Rainbow
Show the color of the color codes in programming buffers.
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :delight
    :hook prog-mode
    :config (rainbow-mode))
#+end_src
**** Rainbow-Delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
   :delight rainbow-delimiters-mode
   :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
**** Eldoc
***** Go
#+begin_src emacs-lisp
  (use-package go-eldoc
    :ensure t
    )
#+end_src
***** Css
#+begin_src emacs-lisp
  (use-package css-eldoc
    :ensure t
    )
#+end_src
***** toml
#+begin_src emacs-lisp
  (use-package eldoc-toml
    :ensure t
    )
#+end_src
**** Rulers

#+begin_src emacs-lisp
  (column-number-mode)
  (global-display-line-numbers-mode t)
#+end_src

Not use rulers in Org-mode and terminal mode
#+begin_src emacs-lisp
  (dolist (mode '(org-mode-hook term-mode-hook eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src
**** No-wraping in programming
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook (lambda () (visual-line-mode -1)))
  (add-hook 'prog-mode-hook (lambda () (setq truncate-lines t)))
#+end_src
**** Useful Right-Click
#+begin_src emacs-lisp
  (when (display-graphic-p)
    (context-menu-mode))
#+end_src
**** Symbols
#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)

#+end_src

#+begin_src emacs-lisp
  (defun prog/prettify-set ()
    (interactive)
    (setq prettify-symbols-alist '(("lambda" . "λ") ("fn" . "𝒇"))))
  (add-hook 'prog-mode-hook 'prog/prettify-set)
#+end_src
**** Org-superstar
#+begin_src emacs-lisp
  (use-package
   org-superstar
   :after org
   :hook (org-mode . org-superstar-mode)
   :custom (org-superstar-headline-bullets-list '("█" "▓" "▒" "░")))

#+end_src

*** auto-compile
#+begin_src emacs-lisp
  (use-package auto-compile :config (auto-compile-on-load-mode))
#+end_src
*** Editing
**** Revert mode
#+BEGIN_SRC emacs-lisp
  ;; Set the auto-revert interval to 1 second
  (setq auto-revert-interval 1
        ;; Enable checking for version control system info
        auto-revert-check-vc-info t)

  ;; Enable global auto-revert mode
  (global-auto-revert-mode 1)
#+END_SRC

**** Surrounding
something is here
#+begin_src emacs-lisp
  (use-package evil-surround
   :ensure t
   :after evil
   :config (global-evil-surround-mode 1))
#+end_src
**** Multiple Cursors
#+begin_src emacs-lisp
  (use-package evil-mc
    :after evil
    :init (global-evil-mc-mode 1))
#+end_src
**** Commenting
#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
    :after evil
    :defer 2
    :bind ("M-;" . evilnc-comment-or-uncomment-lines)
    :config (evil-commentary-mode))
#+end_src
**** Doule space is off
#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src
**** Yasnippet
#+begin_src emacs-lisp :tangle no
  (use-package yasnippet
   :ensure t
   :general (nmap :prefix "SPC" "yt" 'yas-describe-tables)
   :init (yas-global-mode 1)
   :hook ((eglot-mode . yas-minor-mode))
   :custom (yas-prompt-functions 'yas-ido-prompt))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package yasnippet-snippets
    :ensure t
    :after yasnippet)
#+end_src
*** Reformating
**** delete trailing line
Delete extra spaces at the end of the line before saving.
#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
**** elisp-autofmt
#+begin_src emacs-lisp
(use-package
 elisp-autofmt
 :commands (elisp-autofmt-mode elisp-autofmt-buffer)
 :hook (emacs-lisp-mode . elisp-autofmt-mode))

#+end_src
*** GNUTLS
Increase the cryptographic security by inceasing minimum size (in bits) of the prime numbers used in cryptographic operations.
#+begin_src emacs-lisp
  (setq gnutls-min-prime-bits 4096)
#+end_src
*** Format
#+begin_src emacs-lisp
    (use-package format-all
    :ensure t
    :hook (prog-mode . format-all-mode)
    :init (setq format-all-formatters '(("Go" goimports)
                                      ("Nix" alejandra)
  ;;                                       ("SQL" pgformatter)
                                        ("HTML" prettier)
  ;;                                       ("Shell" shfmt)
  ;;                                       ("Lua" prettier)
                                        ))

    )
#+end_src
*** OrgMode
**** org-mode
#+begin_src emacs-lisp
  (defun prma/org-mode-setup ()
    (org-indent-mode 1)
    (truncate-lines t)
    )
#+end_src

#+begin_src emacs-lisp
  (use-package org
   :ensure t
   :hook (org-mode . prma/org-mode-setup)
   :general
    (nmap
        :prefix "SPC"
        "o" '(nil :which-key "org")
        "ot" '(nil :which-key "table")
        "ota" 'org-table-align
        "od" 'org-todo
        "os" 'org-schedule
        "ol" 'org-agenda-list
        "oD" 'org-deadline
        "oT" 'counsel-org-tag
        "oe" 'org-set-effort
        "op" 'org-set-property
        "oc" 'org-capture)
   :custom
    (org-directory "~/repos/notes/")
    (org-agenda-files '("~/repos/notes/agenda.org" "~/repos/notes/birthdays.org"))
    (org-ellipsis " ▨")
    (org-agenda-start-with-log-mode t)
    (org-log-done 'time)
    (org-src-fontify-natively t)
    (org-fontify-quote-and-verse-blocks t)
    (org-src-tab-acts-natively t)
    (org-log-into-drawer t)
    (org-capture-templates
            `(("t" "TASKS")
            ("j" "JOURNAL")
            ("jj"
            "Journal"
            entry
            (file+olp+datetree "~/repos/notes/journal.org")
            "\n** %<%H:%M>  :journal:\n\n%?\n\n"
            :clock-in
            :clock-resume
            :empty-lines 0)))
    (org-tag-alist
    `((:startgroup)
      (:endgroup)
      ("@asanbilit" . ?a)
      ("@home" . ?h)
      ("@famedly" . ?f)
      ("@kitkat" . ?f))))
#+end_src


**** soft-wrap
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src
**** Entangler
Automatically tangle our Emacs.org config file when we save it
#+begin_src emacs-lisp
  (defun prma/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/willow/home/emacs.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'prma/org-babel-tangle-config)))
#+end_src

#+RESULTS:
| (lambda nil (add-hook 'after-save-hook #'prma/org-babel-tangle-config)) | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | org-tempo-setup | (closure (t) nil (set (make-local-variable 'company-backends) '(company-org-block)) (company-mode 1)) | org-superstar-mode | evil-org-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | prma/org-mode-setup | (closure (t) nil (display-line-numbers-mode 0)) | org-eldoc-load |

#+begin_src emacs-lisp
    (require 'org-tempo)
#+end_src

#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("els" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("go" . "src go"))
(add-to-list 'org-structure-template-alist '("rs" . "src rust"))
#+end_src
*** Eldoc
#+begin_src emacs-lisp
  (use-package eldoc
    :ensure t
    :hook (emacs-lisp-mode . eldoc-mode))
#+end_src
*** Dired
#+begin_src emacs-lisp
  (rune/leader-keys "."
    '(find-file :which-key "dired"))

  (add-hook 'dired-mode-hook 'dired-hide-details-mode)

  (setq-default dired-dwim-target t
  dired-listing-switches "-alGhv --group-directories-first"
  dired-recursive-copies 'always
  dired-kill-when-opening-new-dired-buffer t)
#+end_src
*** Projectile
#+begin_src emacs-lisp
 (use-package projectile
  :delight projectile-mode
   :config
   (projectile-mode 1)
   (rune/leader-keys "p" '(projectile-switch-project :which-key "switch project"))
   :custom ((projectile-enable-caching t) (projectile-completion-system 'ivy))
   :bind-keymap ("C-c p" . projectile-command-map)
   :general (nmap
        :prefix "SPC"
        "p" '(projectile-switch-project :which-key "switch project"))
   :init
   ;; note: set this to the folder where you keep your git repos!
   ;; (when (file-directory-p "~/repos")
   ;;   (setq projectile-project-search-path '("~/repos")))
   (setq projectile-project-search-path '("~/willow/" "~/repos/"))
   (setq projectile-switch-project-action #'projectile-dired))
#+end_src

*** Counsel-projectile
#+begin_src emacs-lisp
      (use-package counsel-projectile
        :after projectile
        :config (counsel-projectile-mode 1)
      )
#+end_src

*** Term
**** term
#+begin_src emacs-lisp
(use-package
 term
 :commands term
 :config
 (setq explicit-shell-file-name
       "fish") ;; Change this to zsh, etc
 ;;(setq explicit-zsh-args '())         ;; Use 'explicit-<shell>-args for shell-specific args

 ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
 (setq term-prompt-regexp
       "^[^#$%>\n]*[#$%>] *"))

#+end_src
**** vterm
#+begin_src emacs-lisp
(use-package
 vterm
 :commands vterm
 :general
 (nmap
  :prefix
  "SPC"
  "v"
  'projectile-run-vterm)
 :config
 (setq term-prompt-regexp
       "^[^#$%>\n]*[#$%>] *") ;; Set this to match your custom shell prompt
 (setq vterm-shell "fish") ;; Set this to customize the shell to launch
 (setq vterm-max-scrollback 10000))
#+end_src

#+begin_src emacs-lisp
  (global-set-key [f2] 'vterm-toggle)
  (global-set-key
   [C-f2] 'vterm-toggle-cd)
  ;; an cd to the directory where previous buffer file exists
  ;; after I have toggle to the vterm buffer with `vterm-toggle'.
  ;; (define-key
  ;;   'vterm-mode-map
  ;;  [(control return)]
  ;;  #'vterm-toggle-insert-cd)

  ;Switch to next vterm buffer
  ;; (define-key
  ;;  'vterm-mode-map
  ;;  (kbd "s-n")
  ;;  'vterm-toggle-forward)
  ;Switch to previous vterm buffer
  (setq vterm-toggle-fullscreen-p nil)
  (add-to-list
   'display-buffer-alist
   '((lambda (buffer-or-name _)
       (let ((buffer
              (get-buffer
               buffer-or-name)))
         (with-current-buffer buffer
           (or (equal
                major-mode
                'vterm-mode)
               (string-prefix-p
                vterm-buffer-name
                (buffer-name
                 buffer))))))
     (display-buffer-reuse-window
      display-buffer-at-bottom)
     ;;(display-buffer-reuse-window display-buffer-in-direction)
     ;;display-buffer-in-direction/direction/dedicated is added in emacs27
     ;;(direction . bottom)
     ;;(dedicated . t) ;dedicated is supported in emacs27
     (reusable-frames . visible)
     (window-height . 0.3)))

#+end_src

#+begin_src emacs-lisp
  (use-package multi-vterm
   :ensure t
   :config
          (add-hook 'vterm-mode-hook
                          (lambda ()
                          (setq-local evil-insert-state-cursor 'box)
                          (evil-insert-state)))
          (define-key vterm-mode-map [return]                      #'vterm-send-return)

          (setq vterm-keymap-exceptions nil)
          (evil-define-key 'insert vterm-mode-map (kbd "C-e")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-f")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-a")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-v")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-b")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-w")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-u")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-n")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-m")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-p")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-j")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-k")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-r")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-t")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-g")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-c")      #'vterm--self-insert)
          (evil-define-key 'insert vterm-mode-map (kbd "C-SPC")    #'vterm--self-insert)
          (evil-define-key 'normal vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
          (evil-define-key 'normal vterm-mode-map (kbd ",c")       #'multi-vterm)
          (evil-define-key 'normal vterm-mode-map (kbd ",n")       #'multi-vterm-next)
          (evil-define-key 'normal vterm-mode-map (kbd ",p")       #'multi-vterm-prev)
          (evil-define-key 'normal vterm-mode-map (kbd "i")        #'evil-insert-resume)
          (evil-define-key 'normal vterm-mode-map (kbd "o")        #'evil-insert-resume)
          (evil-define-key 'normal vterm-mode-map (kbd "<return>") #'evil-insert-resume))
#+end_src

*** Direnv
#+begin_src emacs-lisp
  (use-package direnv
   :ensure t
   :config
    (direnv-mode 1)
    )
#+end_src

*** Timemachine
#+begin_src emacs-lisp :lexical no
  (use-package git-timemachine
    :ensure t
    )
#+end_src

*** Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :defer 3
    :general
     (nmap
     :prefix "SPC"
     "g" '(nil :which-key "magit")
     "gs" 'magit-status
     "gb" 'magit-blame
     "gP" 'magit-push
     "gp" 'magit-pull
     "gc" 'magit-commit
     ))
#+end_src

*** Git-gutter
#+begin_src emacs-lisp
  (use-package git-gutter
    :ensure t
    :defer 3
    :config (global-git-gutter-mode))
#+end_src

*** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (prog-mode . flycheck-mode))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package flycheck-golangci-lint
    :ensure t
    :hook (go-mode . flycheck-golangci-lint-setup))

#+end_src
#+begin_src emacs-lisp
    (use-package
     flycheck-eglot
     :ensure t
     :after (flycheck eglot)
     :config (global-flycheck-eglot-mode 1)
     )
#+end_src
*** Languages
**** Rust
#+begin_src emacs-lisp
  (use-package
   rustic
   :defer t
   :custom
   (lsp-rust-analyzer-cargo-watch-command "clippy")
   (lsp-rust-analyzer-server-display-inlay-hints t)
   (rustic-format-on-save t)
   (rustic-lsp-client 'eglot)
   :config (add-hook 'rustic-mode-hook '+rustic-mode-hook))
#+end_src

#+begin_src emacs-lisp
  (defun +rustic-mode-hook ()
    "Don't prompt for confirmation before running `rustfmt'."
    (setq-local buffer-save-without-query t)
    :mode (("\\.rs\\'" . rustic)))

  (add-hook 'rust-mode-hook #'lsp)
#+end_src
**** Web-mode
#+begin_src emacs-lisp
(use-package
 web-mode
 :ensure t
 :custom
 (web-mode-code-indent-offset 2)
 (web-mode-markup-indent-offset 2))

#+end_src
**** Nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")
#+end_src
**** Go
#+begin_src emacs-lisp
  (use-package go-mode
    :defer t
    :mode (("\\.go\\'" . go-mode)))
#+end_src

#+begin_src emacs-lisp
  (add-hook 'go-mode-hook 'go-eldoc-setup)
#+end_src
#+begin_src emacs-lisp
  (require 'project)

  (defun project-find-go-module (dir)
    (when-let ((root (locate-dominating-file dir "go.mod")))
      (cons 'go-module root)))

  (cl-defmethod project-root ((project (head go-module)))
    (cdr project))

  (add-hook 'project-find-functions #'project-find-go-module)
#+end_src
*** LSP
**** Logs
#+begin_src emacs-lisp
  (setq lsp-log-io nil)
#+end_src

**** Eglot
#+begin_src emacs-lisp
(advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
#+end_src

#+begin_src emacs-lisp
  (rune/leader-keys "lf" '(eglot-format-buffer :which-key "format"))
  (rune/leader-keys "ld"  '(xref-find-definitions :which-key "go to definiton"))
  (rune/leader-keys "li" '(eglot-find-implementations :which-key "references"))
  (rune/leader-keys "lr" '(eglot-rename :which-key "rename"))
  (rune/leader-keys "la" '(eglot-code-actions :which-key "code-actions"))
#+end_src

#+begin_src emacs-lisp
    (setq-default eglot-workspace-configuration
        '((:gopls .
            (
             (completeUnimported . t)
             (usePlaceholders . t)
             ))))

#+end_src

#+begin_src emacs-lisp :lexical no
(use-package
 eglot
 :ensure t
 :defer t
 :hook
 ((nix-mode . eglot-ensure)
  (go-ts-mode . eglot-ensure)
  (go-mode . eglot-ensure)
  (go-mod-ts-mode . eglot-ensure)
  (rust-mode . eglot-ensure)
  (rust-ts-mode . eglot-ensure)
  (yaml-ts-mode . eglot-ensure)
  (yaml-mode . eglot-ensure)
  (toml-mode . eglot-ensure)
  (toml-ts-mode . eglot-ensure)
  (css-ts-mode . eglot-ensure)
  (css-mode . eglot-ensure)
  (scss-mode . eglot-ensure)
  (bash-mode . eglot-ensure)
  (bash-ts-mode . eglot-ensure)
  (json-ts-mode . eglot-ensure)
  (json-mode . eglot-ensure)
  (dockerfile-ts-mode . eglot-ensure))

 :config
 (setq eglot-extend-to-xref t)
 (setq eglot-events-buffer-size 0)
 (setq read-process-output-max (* 1024 1024)))
#+end_src

#+begin_src emacs-lisp
  (defun eglot-format-buffer-on-save ()
    (add-hook 'before-save-hook #'eglot-format-buffer -10 t))
  (add-hook 'go-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'go-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'rust-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'rust-mod-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'go-mod-ts-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'json-ts-mod-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'json-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'toml-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'toml-ts-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'nix-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'css-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'css-ts-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'scss-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'html-mode-hook #'eglot-format-buffer-on-save)
  (add-hook 'html+-mode-hook #'eglot-format-buffer-on-save)
#+end_src

#+begin_src emacs-lisp
  (use-package eldoc-box
    :ensure t
    :hook (eglot-managed-mode . eldoc-box-hover-at-point-mode)
    :after eglot)
#+end_src
*** Completion
**** ivy
#+begin_src emacs-lisp :tangle no
    (use-package ivy
     :delight
     :bind (
      ("C-s" . swiper)
      :map
      ivy-minibuffer-map
      ("TAB" . ivy-alt-done)
      ("C-l" . ivy-alt-done)
      ("C-j" . ivy-next-line)
      ("C-k" . ivy-previous-line)
      :map
      ivy-switch-buffer-map
      ("C-k" . ivy-previous-line)
      ("C-l" . ivy-done)
      ("C-d" . ivy-switch-buffer-kill)
      :map
      ivy-reverse-i-search-map
      ("C-k" . ivy-previous-line)
      ("C-d" . ivy-reverse-i-search-kill))
     :config (ivy-mode 1))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package
 all-the-icons-ivy-rich
 :delight
 :ensure t
 :init (all-the-icons-ivy-rich-mode 1))
#+end_src

#+begin_src emacs-lisp :tangle no
    (use-package ivy-rich
        :delight
        :ensure t
        :init (ivy-rich-mode 1))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package
   ivy-prescient
   :after counsel
   :custom (ivy-prescient-enable-filtering nil)
   :config
   ;; Uncomment the following line to have sorting remembered across sessions!
   (prescient-persist-mode 1) (ivy-prescient-mode 1))

#+end_src
#+begin_src emacs-lisp :tangle no
  (use-package lsp-ivy
      :after lsp
      :ensure t)
#+end_src
**** counsel
#+begin_src emacs-lisp :tangle no
  (use-package counsel
   :delight
   :general
     (nmap
     :prefix "SPC"
     "/" 'counsel-rg
     "i" 'counsel-imenu
     ;"b" 'counsel-switch-buffer
     "f" 'counsel-fzf
     "e" 'counsel-flycheck
     )
   :custom
   (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
   :config (counsel-mode 1))
#+end_src

**** company
#+begin_src emacs-lisp :tangle no
  (use-package company
   :ensure t
   :bind
   (:map company-active-map ("<tab>" . company-complete-selection))
   :config
   (add-hook 'after-init-hook 'global-company-mode)
   (add-to-list 'company-backends 'company-nixos-options)
   (add-to-list 'company-backends 'company-restclient)
   (add-to-list 'company-backends 'company-shell)
   (set-face-attribute `company-tooltip nil
                        :font "Maple Mono"
                        :height 120)

   (set-face-attribute `company-tooltip-annotation nil
                        :font "Maple Mono"
                        :height 100)

   :custom
   (company-tooltip-align-annotations 't)
   (company-tooltip-maximum-width 40)
   (company-minimum-prefix-length 1)
   (company-idle-delay 0.1))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src

#+begin_src emacs-lisp :tangle no
(require 'company-posframe)
(company-posframe-mode 1)
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package company-org-block
    :ensure t
    :custom
    (company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
    :hook ((org-mode . (lambda ()
                         (setq-local company-backends '(company-org-block))
                         (company-mode +1)))))

#+end_src

**** orderless
#+begin_src emacs-lisp

  (use-package orderless
    :demand t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles basic partial-completion))
                                     (eglot (styles orderless))))
    (orderless-component-separator #'orderless-escapable-split-on-space))
#+end_src
**** Vertico
#+begin_src emacs-lisp
  (use-package vertico
    :demand t
    :bind (:map vertico-map
                ([tab] . vertico-next)
                ([backtab] . vertico-previous))
    :custom (vertico-cycle t)
    :config (vertico-mode))
#+end_src
**** Marginalia
#+begin_src emacs-lisp
  (use-package marginalia
    :demand t
    :custom
    (marginalia-align 'right)
    :init (marginalia-mode))
#+end_src
**** Consult
#+begin_src emacs-lisp
  (use-package consult
    :init

        ;; Optionally configure the register formatting. This improves the register
        ;; preview for `consult-register', `consult-register-load',
        ;; `consult-register-store' and the Emacs built-ins.
        (setq register-preview-delay 0.5
                register-preview-function #'consult-register-format)

        ;; Optionally tweak the register preview window.
        ;; This adds thin lines, sorting and hides the mode line of the window.
        (advice-add #'register-preview :override #'consult-register-window)

    ;;     ;; Use Consult to select xref locations with preview
        (setq xref-show-xrefs-function #'consult-xref
                xref-show-definitions-function #'consult-xref)

    ;; :defer 0.5
    :general (nmap :prefix "SPC"
               "b" 'consult-projectile-switch-to-buffer
               "p" 'consult-projectile
               "m" 'consult-minor-mode-menu
               "f" 'consult-fd
               "i" 'consult-imenu
               "/" 'consult-ripgrep
               "e" 'consult-flycheck
               )
    :bind (([remap repeat-complex-command] . consult-complex-command)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
           ([remap switch-to-buffer-other-frame] . consult-buffer-other-frame)
           ([remap project-switch-to-buffer] . consult-project-buffer)
           ([remap bookmark-jump] . consult-bookmark)
           ([remap goto-line] . consult-goto-line)
           ([remap imenu] . consult-imenu)
           ([remap yank-pop] . consult-yank-pop)
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)
           ("M-g o" . consult-outline)
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-s e" . consult-isearch-history)
           ("M-s l" . consult-line)
           :map minibuffer-local-map
           ("M-s" . consult-history))
    :custom
    (consult-preview-at-point-mode t)
    (register-preview-delay 0.5)
    (register-preview-function #'consult-register-format)
    (consult-narrow-key "<")
    (xref-search-program 'ripgrep)
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref)
    :commands consult--customize-put
    :config
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     :preview-key "M-.")
    )
#+end_src

#+begin_src emacs-lisp
(defun consult--orderless-regexp-compiler (input type &rest _config)
  (setq input (orderless-pattern-compiler input))
  (cons
   (mapcar (lambda (r) (consult--convert-regexp r type)) input)
   (lambda (str) (orderless--highlight input str))))

(setq consult--regexp-compiler #'consult--orderless-regexp-compiler)
#+end_src
**** Embark
#+begin_src emacs-lisp

  (use-package embark
    :bind
    ("C-." . embark-act)
    ("M-." . embark-dwim)
    ("C-h b" . embark-bindings)
    ("C-h B" . embark-bindings-at-point)
    ("M-n" . embark-next-symbol)
    ("M-p" . embark-previous-symbol)
    (:map dired-mode-map ("e" . dired-open-externally))
    :custom
    (embark-quit-after-action nil)
    (prefix-help-command #'embark-prefix-help-command)
    (embark-indicators '(embark-minimal-indicator
                         embark-highlight-indicator
                         embark-isearch-highlight-indicator))
    (embark-cycle-key ".")
    (embark-help-key "?")
    :commands embark-open-externally
    :config
    (setq embark-candidate-collectors
          (cl-substitute 'embark-sorted-minibuffer-candidates
                         'embark-minibuffer-candidates
                         embark-candidate-collectors))
    (defun dired-open-externally (&optional arg)
      "Open marked or current file in operating system's default application."
      (interactive "P")
      (dired-map-over-marks (embark-open-externally (dired-get-filename)) arg)))
#+end_src

#+begin_src emacs-lisp
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
**** Tempel
#+begin_src emacs-lisp
  (use-package tempel
  ;; :custom
  ;; (tempel-trigger-prefix "<")

   :init
   ;; Setup completion at point
   (defun tempel-setup-capf ()
     ;; Add the Tempel Capf to `completion-at-point-functions'.
     ;; `tempel-expand' only triggers on exact matches. Alternatively use
     ;; `tempel-complete' if you want to see all matches, but then you
     ;; should also configure `tempel-trigger-prefix', such that Tempel
     ;; does not trigger too often when you don't expect it. NOTE: We add
     ;; `tempel-expand' *before* the main programming mode Capf, such
     ;; that it will be tried first.
     (setq-local completion-at-point-functions
                 (cons #'tempel-expand completion-at-point-functions)))

   (add-hook 'conf-mode-hook 'tempel-setup-capf)
   (add-hook 'prog-mode-hook 'tempel-setup-capf)
   (add-hook 'text-mode-hook 'tempel-setup-capf)
   (add-hook 'rust-mode-hook 'tempel-setup-capf)

   ;; Optionally make the Tempel templates available to Abbrev,
   ;; either locally or globally. `expand-abbrev' is bound to C-x '.
   ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
   (global-tempel-abbrev-mode))
#+end_src

#+begin_src emacs-lisp
(use-package tempel-collection)
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/templates
  rustic-mode
  (ttat "s" p "{};")

  rust-mode
  (ttat "s" p "{};")
  rust-ts-mode
  (ttat "s" p "{};")
#+end_src
**** Corfu
#+begin_src emacs-lisp
    (use-package corfu
      :delight
      :custom
      (corfu-cycle t)
      (corfu-auto t)
      (corfu-auto-prefix 1)
      (corfu-auto-delay 0.1)
      (corfu-preselect 'prompt)
      (corfu-on-exact-match nil)
      (corfu-popupinfo-delay 0.1)
      (corfu-echo-delay 0.1)
      (corfu-prescient-mode 1)
      :bind (:map corfu-map
                  ([tab] . corfu-next)
                  ([backtab] . corfu-previous)
                  ("S-<return>" . corfu-insert)
                  ("RET" . nil)
                  ([remap move-end-of-line] . nil))
      :hook (eshell-mode . (lambda () (setq-local corfu-auto nil)))
      :init
      (global-corfu-mode)
      (corfu-history-mode)
      (corfu-echo-mode)
      (corfu-popupinfo-mode))

    (defun my/eglot-capf ()
    (setq-local completion-at-point-functions
                (list (cape-super-capf
                       #'eglot-completion-at-point
                       #'tempel-expand
                       #'cape-file))))

  (add-hook 'eglot-managed-mode-hook #'my/eglot-capf)
#+end_src
**** dabbrev
#+begin_src emacs-lisp
    ;; Use Dabbrev with Corfu!
    (use-package dabbrev
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-completion)
            ("C-M-/" . dabbrev-expand))
    ;; Other useful Dabbrev configurations.
    :custom
    (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src
*** treesit
#+begin_src emacs-lisp
  (setq major-mode-remap-alist
           '((conf-toml-mode  . toml-ts-mode)
             (go-mode         . go-ts-mode)
             (go-mod-mode     . go-mod-ts-mode)
             (rust-mode       . rust-ts-mode)
             (json-mode       . json-ts-mode)
             (yaml-mode       . yaml-ts-mode)
             (css-mode        . css-ts-mode)
             (java-mode       . java-ts-mode)
             (javascript-mode . js-ts-mode)
             (js-json-mode    . json-ts-mode)
             (python-mode     . python-ts-mode)
             (ruby-mode       . ruby-ts-mode)
             (sh-mode         . bash-ts-mode)))
  (add-to-list 'auto-mode-alist '("\\(?:CMakeLists\\.txt\\|\\.cmake\\)\\'" . cmake-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . tsx-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))
#+end_src
*** Mastodon
#+begin_src emacs-lisp
  (use-package mastodon
    :ensure t
    :custom
    (mastodon-instance-url "https://fosstodon.org")
    (mastodon-active-user "prma")
    :config
    (mastodon-discover))
#+end_src
*** Easy hugo
#+begin_src emacs-lisp
  (use-package easy-hugo
    :ensure t
    :bind ("C-c C-k" . easy-hugo-menu)
    :config
    (easy-hugo-enable-menu)
    :custom
    (easy-hugo-server-flags "-D")
    (easy-hugo-server-flags "-D")
    (easy-hugo-default-ext ".org")
    (easy-hugo-ext ".org")
    (easy-hugo-no-help nil)
    (easy-hugo-basedir "~/repos/prmadev_v3")
    (easy-hugo-url "https://prma.dev")
    (easy-hugo-postdir "content/posts")
    (easy-hugo-org-header t)
  )
#+end_src
*** Small Garbage-collector
#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 200 1000 1000))
#+end_src
